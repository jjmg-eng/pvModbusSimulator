//***************************************************************************
//                          pvapp.h  -  description
//                             -------------------
//  begin            : ter mai 7 07:25:59 2024
//  generated by     : pvdevelop (C) Lehrig Software Engineering
//  email            : lehrig@t-online.de
//***************************************************************************
#ifndef _PVAPP_H_
#define _PVAPP_H_

#ifdef USE_INETD
static int trace=0; // todo: set trace=0 if you do not want printf() within event loop
#else
static int trace=1; // todo: set trace=0 if you do not want printf() within event loop
#endif

#include "processviewserver.h"
// todo: comment me out
#include "rlmodbusclient.h"
//#include "rlsiemenstcpclient.h"
//#include "rlppiclient.h"
#include "modbusdaemon.h"             // this is generated. Change for name.h -> "name.mkmodbus"
//#include "siemensdaemon.h"            // this is generated
//#include "ppidaemon.h"                // this is generated

int show_mask1(PARAM *p);

//***************************************************************************
//                                 mainloop.h
//                                 ----------
//  O código a seguir foi incluído diretamente em "pvapp.h" por esta ser uma 
//  aplicação pequena.
//  Em projetos maiores, será mais adequado que seja criado um arquivo a parte
//  com o nome "mainloop.h".
//  O objetivo de mainloop é criar uma thread que permita executar lógicas 
//  independentes das masks usando o estilo dos programas para Arduino com
//  setup() e loop().
// 
#ifndef _MAINLOOP_
#define _MAINLOOP_

// GLOBAL

#include "stdlib.h"
#include "rlthread.h"
#include "math.h"
#define PI 3.14159265358979323846

typedef struct{
int amp, T, fase, offset;
} sig;

/////////////////////////////////////////////
#ifndef _MAIN_  // Código exclusivo das Masks
/////////////////////////////////////////////
extern rlMutex    dbmutex;
extern sig AI[8];

/////////////////////////////////////////////////////////////////
#else // Aqui começa o código que vai ser compilado na seção Main
/////////////////////////////////////////////////////////////////

rlModbusClient     modbus(modbusdaemon_MAILBOX,modbusdaemon_SHARED_MEMORY,modbusdaemon_SHARED_MEMORY_SIZE);
rlThread   usrThread;
rlMutex    dbmutex;

sig AI[8] = {	{10000, 10000,    0, 0},
		{10000, 10000,  120, 0},
		{10000, 10000,  240, 0},
		{ 5000,  5000,    0, 50},
		{10000, 10000, 0, 0},
		{10000, 10000, 0, 0},
		{10000, 10000, 0, 0},
		{10000, 10000, 0, 0}};

static void task01()
{
	static int i = 0;
	int delta, val, j, slave = 3;	
	float teta, x;
	for(j = 0; j<8; j++){
		delta = AI[j].T/100;
		teta = (i % delta) * 2 * PI / delta; 
		teta = teta + AI[j].fase * PI / 180;
		x = AI[j].amp * sin(teta) / 100 + AI[j].offset;
		x = x < -100 ? -100 : x > 100 ? 100 : x;
		val = (x + 100) * 100;
		modbus.writePresetSingleRegister(slave,j,val);
	}
	i++;
};

static void task02()
{
 	static int i = 0;
 	i++;
};

static void setup()
{
};

#define TZ 100

static void loop()
{
	static int i = 0;
	if(!(i%10)) task01(); // Chamar task01 a cada 1 segundo
	if(!(i%30)) task02(); // Chamar task02 a cada 3 segundos
	i++;
	pvSleep(TZ); // TZ = 100 ms
};

static void *usrMain(void *arg)
{
 setup();
 while(1) loop();
 return arg;
};

////////////////////////////////////////////////////////////////////////

#endif

#endif

// FIM DE _MAINLOOP_
//
//***************************************************************************


#endif
